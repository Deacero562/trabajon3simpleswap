// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

/// @title SimpleSwapV2
/// @notice Intercambio bÃ¡sico entre dos tokens ERC20 con funcionalidad de liquidez
contract SimpleSwapV2 {
    using SafeERC20 for IERC20;

    IERC20 public immutable tokenX;
    IERC20 public immutable tokenY;

    uint256 public reserveX;
    uint256 public reserveY;

    mapping(address => uint256) public liquidity;
    uint256 public totalLiquidity;

    uint256 private constant FEE = 3; // 0.3% fee
    uint256 private constant FEE_BASE = 1000;

    event LiquidityProvided(address indexed provider, uint256 amountX, uint256 amountY, uint256 liquidityMinted);
    event LiquidityRemoved(address indexed provider, uint256 amountX, uint256 amountY, uint256 liquidityBurned);
    event TokenSwapped(address indexed user, address indexed fromToken, address indexed toToken, uint256 amountIn, uint256 amountOut);

    constructor(address _tokenX, address _tokenY) {
        require(_tokenX != _tokenY, "Tokens must differ");
        require(_tokenX != address(0) && _tokenY != address(0), "Zero address");
        tokenX = IERC20(_tokenX);
        tokenY = IERC20(_tokenY);
    }

    function provideLiquidity(uint256 amountX, uint256 amountY) external returns (uint256 liquidityMinted) {
        require(amountX > 0 && amountY > 0, "Zero amount");

        tokenX.safeTransferFrom(msg.sender, address(this), amountX);
        tokenY.safeTransferFrom(msg.sender, address(this), amountY);

        if (totalLiquidity == 0) {
            liquidityMinted = sqrt(amountX * amountY);
        } else {
            liquidityMinted = min(
                (amountX * totalLiquidity) / reserveX,
                (amountY * totalLiquidity) / reserveY
            );
        }

        require(liquidityMinted > 0, "Zero liquidity minted");

        liquidity[msg.sender] += liquidityMinted;
        totalLiquidity += liquidityMinted;

        reserveX += amountX;
        reserveY += amountY;

        emit LiquidityProvided(msg.sender, amountX, amountY, liquidityMinted);
    }

    function removeLiquidity(uint256 liquidityAmount) external returns (uint256 amountX, uint256 amountY) {
        require(liquidity[msg.sender] >= liquidityAmount, "Insufficient liquidity");

        amountX = (liquidityAmount * reserveX) / totalLiquidity;
        amountY = (liquidityAmount * reserveY) / totalLiquidity;

        require(amountX > 0 && amountY > 0, "Zero amounts");

        liquidity[msg.sender] -= liquidityAmount;
        totalLiquidity -= liquidityAmount;

        reserveX -= amountX;
        reserveY -= amountY;

        tokenX.safeTransfer(msg.sender, amountX);
        tokenY.safeTransfer(msg.sender, amountY);

        emit LiquidityRemoved(msg.sender, amountX, amountY, liquidityAmount);
    }

    function swap(address fromToken, uint256 amountIn) external returns (uint256 amountOut) {
        require(amountIn > 0, "Zero input");
        require(fromToken == address(tokenX) || fromToken == address(tokenY), "Invalid token");

        bool isXtoY = fromToken == address(tokenX);

        IERC20 inputToken = isXtoY ? tokenX : tokenY;
        IERC20 outputToken = isXtoY ? tokenY : tokenX;

        uint256 reserveIn = isXtoY ? reserveX : reserveY;
        uint256 reserveOut = isXtoY ? reserveY : reserveX;

        inputToken.safeTransferFrom(msg.sender, address(this), amountIn);

        uint256 amountInWithFee = (amountIn * (FEE_BASE - FEE)) / FEE_BASE;
        amountOut = (amountInWithFee * reserveOut) / (reserveIn + amountInWithFee);

        require(amountOut > 0 && amountOut < reserveOut, "Invalid output");

        outputToken.safeTransfer(msg.sender, amountOut);

        if (isXtoY) {
            reserveX += amountIn;
            reserveY -= amountOut;
        } else {
            reserveY += amountIn;
            reserveX -= amountOut;
        }

        emit TokenSwapped(msg.sender, address(inputToken), address(outputToken), amountIn, amountOut);
    }

    function getPrice(address fromToken) external view returns (uint256 price) {
        require(fromToken == address(tokenX) || fromToken == address(tokenY), "Invalid token");

        if (fromToken == address(tokenX)) {
            price = (reserveY * 1e18) / reserveX;
        } else {
            price = (reserveX * 1e18) / reserveY;
        }
    }

    function sqrt(uint256 y) private pure returns (uint256 z) {
        if (y > 3) {
            z = y;
            uint256 x = y / 2 + 1;
            while (x < z) {
                z = x;
                x = (y / x + x) / 2;
            }
        } else if (y != 0) {
            z = 1;
        }
    }

    function min(uint256 a, uint256 b) private pure returns (uint256) {
        return a < b ? a : b;
    }
}
